#### Рефакторинг 1.
В проекте есть папка asset.release.application.model, которая находится в модуле asset-release-app, со следующей структурой:
- model
  - database
  - accounting
  - po

Прямо в папке model лежат DTO, которые используются в проекте.

В папке database лежат сущности БД - entities.

В папке accounting лежат специальные DTO, которые отсылаются в систему учета.

В папке po лежат DTO, которые используются для одного из процессов в системе.

Также в проекте присутствуют несколько модулей maven, где собраны классы с бизнес-логикой для интеграции с разными системами. И в этих модулях также есть DTO, которые используются для транспорта между системами.

Возможно, тут следует выделить отдельный модуль, где будут собраны все DTO. Разложить их по пакетам, в соответствии с их назначением. И подключать этот модуль в качестве зависимости в другие модули.
Так мы отделим классы, предназначенные для обмена между системами, от бизнес логики, находящейся в модуле asset-release-app и интеграционных модулях.
Также этот модуль может выполнять роль спецификации для нашего публичного API.

#### Рефакторинг 2.

Система предназначена для получения котировок из различных third party систем и пересылку их в систему учета.
Здесь можно выделить 3 процесса:
1. Регистрация сущности "Конфигурация потока котировок" - QuotationFlowConfiguration. Он содержит информацию о системе, из которой приходят котировки, id в нашей БД, id в системе учета и т.д.
2. Отправка в third party систему запроса на подписку, чтобы система начала присылать котировки.
3. Обработка сообщений c котировками от third party системы: преобразование присланного сообщения в объект нашей доменной модели, сохранение в нашу БД, и пересылка в систему учета.

Есть контроллер QuotationFlowController. Он который отвечает и за регистрацию конфигурации, и за подписку.
В рамках рефакторинга его можно разделить на 2 контроллера - QuotationFlowConfigurationController и SubscriptionController, чтобы каждый контроллер отвечал за свой процесс.

После этого можно провести рефакторинг части кода, который отвечает за подписку, чтобы очертить ее границы с помощью интерфейса. 
Изначально наш контроллер имел поля - сервисы, которые отвечали за подписку на определенный источник.
```
public class QuotationFlowController {
    private FIXService fixService;
    private TxpSubscriptionMessageProcessor txpSubscriptionMessageProcessor;
    ...
}
```
Можно сделать единый интерфейс SubscriptionService, который будут реализовывать оба класса.
```
public interface SubscriptionService {
    void subscribe();
    void unsubscribe();
}
```
public class FIXService implements SubscriptionService { ... }
public class TxpSubscriptionMessageProcessor implements SubscriptionService { ... }

Таким образом мы ограничим часть системы, которая отвечает за подписку.
У нас уже были тесты для проверки регистрации конфигурации, написала тесты для проверки подписки. В тесте проверяю, что сообщение о подписке корректно формируется и вызывается метод для отправки в third party system.

#### Рефакторинг 3.
 
В получившимся классе QuotationFlowConfigurationController есть только 1 метод, который принимает QuotationFlowConfiguration для всех third party систем.
И есть поле - сервис RegistrationService, который отвечает за проверку корректности QuotationFlowConfiguration, сохранение в БД, и отправку в систему учета.
Изначально было всего 2 типа конфигурации с идентичными параметрами, поэтому один сервис мог обрабатывать оба типа конфигураций.
Но потом добавились другие, и в сервисе появился и разросся метод валидации, в котором определяется тип конфигурации и для каждой системы прописаны свои проверки корректности.

Можно сделать отдельные методы регистрации для каждого типа конфигурации в контроллере, а также сделать RegistrationService интерфейсом для конкретных реализаций (TxpRegistrationService, FIXRegistrationService и т.д) для каждой из систем, где будут специфичные для них проверки.
