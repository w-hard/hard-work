### 1. Зависимость фреймворка.
В первом задании по зависимостям привела такой пример:
" У нас на проекте используется паттерн Messaging, входящие сообщения сохраняются в БД для последующей обработки. И есть сервис А, который извлекает эти сообщения из БД, определяет тип, и передает сообщение конкретному обработчику. 
Хотя сервис вызывает каждый из обработчиков, сам он от них не зависит."

В материале "Избавляемся от зависимостей 3" было указано, что в программировании мы обычно имеем дело с фактической причинностью, а не с общей. 
Поэтому теперь мне кажется, что в данном примере важно дополнить детали: 
если при обработке сообщения возникло исключение, то сервис А пытается его обработать несколько раз, пока не будет достигнут лимит, прежде чем перейти к следующему сообщению.

На практике был случай, когда для одного из обработчиков были неправильно расставлены границы транзакций. 
И если при обработке возникало исключение, то оно обрабатывалось все в той же транзакции. 
Обработчик увеличивал счетчик попыток для сообщения, но т.к. ранее было выброшено исключение, транзакция была помечена на откат, и это увеличение счетчика просто не сохранялось в БД.
И сервис А уходил в бесконечный цикл, пытаясь обработать одно неуспешное сообщение. 

Мне кажется это иллюстрация решения зависимости фреймворка, которая приведена в материале "Избавляемся от зависимостей 2" -- 
"чтобы избавиться от зависимости, надо запретить задачи, которые долго не завершаются".

В моем примере, когда ошибка стала обрабатываться в в отдельной транзакции, сервис А стал работать корректно. 

### 2. Зависимость расшаренного формата.
Зависимость: клиент (сервис A) делает запросы к сервису В по API (http-запрос с телом json), и в случае если один из них меняет формат тела запроса, другой ломается.

Для решения этой зависимости можем создать json-схему, которая будет храниться в отдельной библиотеке.  
Каждый из сервисов А и В подключит эту библиотеку в качестве зависимости.
Сервис А будет валидировать тело запроса относительно этой схемы при отправке, а сервис В - при получении.
Так оба сервиса будут зависеть от схемы в библиотеке, а не друг от друга. 


### 3. Зависимость зависимости.
В первом задании по зависимостям привела такой пример:

"Сервис A вызывает сервис B, и делает расчеты на основе полученных данных. Сервис C ежедневно по расписанию отправляет данные в B. Если С перестанет отправлять данные, то расчеты в A сломаются, хотя A вроде никак не зависит от С."

Чтобы избавиться от зависимости А от С, необходимо наложить на C ограничение, которое запрещает менять расписание отправки. А также предусмотреть возможность отказа С. 
В рабочем примере в случае отказа С создается срочная заявка на службу поддержки, которая вручную сохраняет в базу данных В необходимые данные. 
Поэтому можно считать, что корректность работы А не зависит от С. 
Зависит только скорость работы сервиса А, т.к. создание заявки и ручное сохранение может создавать большие задержки.


### 4. Зависимость краша.

В приложении А есть библиотека HirakiCP (database connection pool). В этом пункте хотела бы рассмотреть зависимость приложения от пула соединений. 

В прошлом задании описала ситуацию, когда для Postgres при слишком большом значении maximumPoolSize HirakiCP создавал слишком много соединений, что приводило к отказу БД и по сути отказу приложения, т.к. без БД оно бесполезно. 

Изучив докуметацию по HikariCP, упоминания именно о возможности краша из-за большого числа соединений не нашла, но рекомендации по минимальному и максимальному количеству соединений есть.
https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing

Возможно, это можно считать суперспецификацией. И если количество соединений в нашем приложении остается в рамках формул, предложенных в статье, то можно считать, что зависимости от пула соединений нет.


### 5. Зависимость перебрасывания.
В сервисе А есть такой сценарий: пользователь загружает документ в формате pdf. Задача на распознавание документа отправляется в сервис В, там оператор читает документ и вносит различные параметры, указанные в нем, в специальную форму. 
Потом задача отправляется в сервис С, там документ парсится с помощью AI. Если параметры, которые распознал AI, совпадают с параметрами, которые распознал оператор, то документ считается обработанным.
Но если сервис С с AI недоступен, то документ отправляется другому оператору на распознавание. 

Поэтому сервис А зависит от множества {C, B}. 

Возможное влияние может быть на скорость обработки документа - в случае обработки через AI в сервисе С обработка может быть значительно быстрее.

А вот корректность обработки не зависит от выбора сервиса, т.к. пока не совпадут параметры, заполненные {AI, оператор} или {оператор 1, оператор 2},
документ будет повторно отправляться на обработку. Исходя из небольших размеров и сложности документа, можно пренебречь вероятностью, что несколько операторов сделают одинаковые ошибки.

### 6. Зависимость инверсии.

Возможно тут можно привести в пример ситуацию, когда в Spring мы делаем более компактные классы, которые соответствуют SRP, и в них объявляем переменные не типа интерфейса, а типа класса. У нас все равно под капотом Spring сам инжектирует конкретную реализацию, но в таком случае реализация одна, а не несколько, и не требуется тщательно продумывать, какая именно должна быть инжектирована. 



### 7. Зависимость зацикливания.

В прошлом задании привела такой пример зависимости А от А: 

"В нашей системе есть сервис A, который подключается к серверу B и создает сессию для обмена сообщениями. B-сервер, согласно своей спецификации, может поддерживать только 1 сессию с определенным ID. Для всей нашей системы выдан только один ID. Но у сервиса A есть и другие задачи помимо интеграции с B. И мы бы хотели ускорить их обработку, запустив 2 экземпляра сервиса A (2 пода в openshift). Но когда мы запускаем 2 экземпляра, наше соединение с B-сервером обрывается, т.к. создается 2 сессии с одним и тем же ID. Так А влияет на самого себя.
Для решения этой проблемы создала переменную-флаг в сервисе A, которая задается в config map, и может отключать интеграцию с B-сервером. На одном экземпляре включаем флаг, на другом выключаем."

В данном примере у нас есть такие характеристики сервиса А:

1. Корректность выполнения задач, зависимых  от В. 
2. Скорость обработки других задач, не зависимых от В. Очевидно, эта характеристика не зависит от В.

Если рассматривать характеристику сервиса В "доступность для А", то если мы остаемся в пространстве допустимых изменений (только одна сессия), то зависимости нет. Какие бы данные не отправлял А в В, мы не столкнемся с недоступностью В, если у нас всего одна сессия.

Изначально мы захотели улучшить характеристику сервиса А, не зависимую от В. Своими изменениями мы создали зависимость В от А.
И это повлияло на характеристику А, зависимую от В.
В прошлом задании я предположила, что здесь есть зависимость зацикливания, потому что не разделяла разные характеристики сервиса А.

Насколько понимаю, можно провести такую аналогию с примером из материала:

Я получил смс от X = Сервис А медленно обрабатывает сообщения

Я хочу позвонить Х и нажимаю на неверные кнопки = Я создаю 2-й экземпляр сервиса A и В обрывает существующую сессию с А

Причина обрыва = Мы вышли из пространства допустимых изменений, и создали зависимость В от А.


### 8. Зависимость высшего порядка.

В качестве примера можно привести коллекции на основе деревьев в Java (TreeSet, TreeMap).
Объекты, которые могут храниться в таких коллекциях, должны реализовывать интерфейс Comparable, либо при создании коллекции надо передавать Comparator для сортировки.
Если метод compare будет реализован некорректно, то будет некорректной и работа этих коллекций в рантайме.   

### 9. Зависимость большинства.
Тут возможно подойдет пример, который упоминался в п.5. Обработка документа pdf считается успешной, если при распознавании совпали параметры у хотя бы 2-х участников:
- оператор 1 + AI  или
- оператор 1 + оператор 2 или
- оператор 1 + AI + оператор 2 или
- оператор 1 + оператор 2 + оператор 3 ... и т.д., пока сойдутся результаты распознавания хотя бы у 2-х участников.

В итоге распознавание документа не зависит от конкретного участника (AI или оператор) распознавания, но зависит от каждого подмножества участников размера 2. 


