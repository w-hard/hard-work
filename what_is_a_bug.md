
#### Пример 1.1  Это не баг
Приложение на Java + Spring иммет API - метод createProduct(ProductDto productDto). Соответствующий ему HTTP метод принимает Json, который преобразуется библиотекой Jackson и Spring-ом в ProductDto. У ProductDto есть поле createdAt типа Instant. Есть требование, чтобы в Json в этом поле приходила строка формата "yyyy-MM-dd'T'HH:mm". Для проверки формата используем аннотацию JsonFormat. Она указывает библиотеке Jackson как десериализовать поле createdAt. Если значение не соответствует формату - выбрасывается исключение.
```
@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm", timezone = "UTC")
Instant createdAt;
```
Но если в Json в поле createdAt приходит число - мы хотели бы получать ошибку. Но ее не возникает. И это ожидаемое поведение библиотеки Jackson, она парсит число в тип Instant, даже если мы указали аннотацию JsonFormat.

Попытки привести поведение к ожидаемому показали, что это не так просто. Насколько я поняла, нужно перехватить входящее сообщение до десериализации и проверить поле на соответствие формату. Но за несколько часов так и не удалось пофиксить эту проблему, т.к. исправления нарушали внутреннюю логику Spring, и получались странные ошибки.

Но с другой стороны, возник вопрос, насколько вообще правильно тратить время на решение этой проблемы. Этот API не предоставляется клиенту напрямую. Клиент заполняет форму на UI, которая не дает ввести в данное строку в формате, отличном от "yyyy-MM-dd'T'HH:mm". Поэтому на поведение системы в целом это не влияет, и в итоге решили оставить как есть. Похоже получился баг, который не баг.



### Пример 2.1 Это не баг (а что-то другое)
Когда в базе данных вместо перечисления используются числа.
Например, таблица Message содержит атрибут type. И вместо значений NEW, PROCESSED, CANCELLED используются числа 1,2,3.
В коде при этом Message.type - это enum, но при сохранении в БД почему-то было выбрано решение преобразовывать enum в число. Хоть это и не баг, но при анализе сообщений в БД очень нечитабельно, и потенциально может привести к ошибочной интерпретации данных.


### Пример 2.2 Это не баг (а что-то другое)
Это возможно методы с высокой цикломатической сложностью.
Например:
```
if(product.getType == TYPE_A) {
    ...
    if(customer.getType == INDIVIDUAL) {
        ...
    } else if (customer.getType == BUSINESS) {
        ...
    } else {
        switch(... ) {
            ...
        }
    }
} else if (product.getType == TYPE_B) {
    if(customer.getType == INDIVIDUAL) {
      ...
    }
} 
```
При внесении изменений в такую конструкцию высока вероятность ошибок, когда разработчик забудет прописать код в какой-то из ветвей. И отловить такую ошибку может быть сложно, т.к. сложно покрыть тестами все ветви, особенно если такая конструкция -- часть длинного метода. 


### Пример 3.1 Это сбивает людей с толку


В сервисе есть эндпойн GET /rate?code={code}&date={date}. Rate переводится как ставка, но на самом деле этот эндпойнт возвращает котировки, т.е сумму в рублях.
В какой-то момент возникла необходимость добавить новый функционал - получать процентные ставки из другой системы, сохранять в БД и добавить эндпойнт, который бы возвращал процентную ставку клиенту сервиса. И из-за названия /rate аналитик посчитал что данный эндпойнт уже отдает процентные ставки, и вместо создания нового эндпойнта прописал расширение логики для старого. Когда разработчик вник в суть, то понял, что это по сути это совсем разные вещи: ставка - это число в процентах, а котировка - это сумма в рублях, и возвращать их через один эндпойнт, значит еще больше запутать проект. Поэтому сделал сделать эндпойнт с другим названием, не таким удачным как rate.
Неправильное именование исходного эндпойнта не было багом, но вносило путаницу. 


#### Пример 4.1 Это хрупкость

Когда у нас в коде есть условный оператор вида
```
if (product instanceof ProductA) {
    ...
} else {

}
```
На момент написания кода имеется всего 2 типа продукта: ProductA и ProductB, и другие продукты не планируются. Но может случится, что требования изменятся, и появится ProductC. С такой конструкцией легко забыть, что нужно обновить поведение для ProductС, и получится баг.


#### Пример 4.2 Это хрупкость

У нас в приложении есть 4 метода, которые выполняются по расписанию. В Spring можно настроить такое поведение с аннотацией @Scheduled.
По умолчанию Spring выделяет пул из 1 потока на все методы с этой аннотацией. А значит, что если у нас 4 Scheduled метода, то они будут выполняться по очереди. 

Можно увеличить размер пула, выставив 4 потока. И можно предположить, что за каждым методом будет закреплен свой поток. Но оказывается, что нет. Что каждый метод просто выполняется в свободном потоке.
Допустим, есть метод callA(), который запускается раз в 30 секунд и вызывает сторонний API системы A, чтобы записать туда данные. Но у системы A бывают проблемы с нагрузкой, и в такие часы вызовы к нему могут занимать от 5 до 60 сек. Наша система в случае долгого вызова будет вести себя так:
1. Запустился callA в потоке 1. Допустим, он выполняется 60 сек, т.к. API долго отвечает.
2. Т.к. 30 сек прошло, и у нас есть свободный поток в пуле, запускается параллельный callA в потоке 2.
3. Может быть так, что callA в потоке 2 займет 20 сек и завершится быстрее чем callA в потоке 1.
4. Какое значение будет записано в системе A? Ожидаем второе, более новое, но теоретически возможно, что видим первое, что будет багом. 

(Предполагаю, что для фикса достаточно сделать вызов callA не раз в 30 секунд, а через 30 секунд после завершения предыдущего callA, Spring дает такую возможность.)


#### Пример 5.1 Не соответствует требованиям OSHA
В проекте есть две подсистемы (допустим ПС1 и ПС2). Общаются подсистемы через Kafka. Когда сообщение Kafka отправляется сервисом A (в ПС1) в сервис B (в ПС2), оно сначала перенаправляется на промежуточный сервер (Валидатор). Валидатор проверяет структуру json-сообщения. Если оно соответствует схеме, которая лежит на Валидаторе, оно отправляется дальше в сервис B. Но если нет, то сообщение просто не пропускается дальше, и сервис B не получает ни ошибки, ни информационного сообщения.
Поэтому когда разработчик добавляет новый тип сообщения Kafka, ему недостаточно просто добавить json-схему в репозиториях A и B. Он также должен пойти к команде промежуточного сервиса и попросить добавить новую схему туда. Когда приходят новые разработчики, они об этом не знают. И такие баги часто ловятся на тестовом стенде, но всплывают только в продакшене.

Мне кажется это как раз сочетание "Сбивает людей с толку" и "Это хрупкость". Т.к. часто даже опытные аналитики и разработчики из нашего проекта забывают о том, что нужно пойти и обновить схему где-то еще.

#### Пример 5.2 Не соответствует требованиям OSHA

У нас в Spring приложении есть различные параметры, которые прописываются в файле application.yml. Также эти параметры могут прописываться в config map у команды devOps.
И параметры config map перетирают то, что лежит в репозитории в application.yml. И бывает, что разработчик не знает об этом моменте, и меняет значения параметров только в репозитории, не уведомляя команду devOps. В результате могут возникать сложно отлавливаемые баги, из-за того, что какой-то параметр, нужный в данной фиче, был задолго до того переопределен в config map у devOps. 
